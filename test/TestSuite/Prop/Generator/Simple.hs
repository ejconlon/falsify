module TestSuite.Prop.Generator.Simple (tests) where

import Test.Tasty
import Test.Tasty.Falsify

import qualified Test.Falsify.Generator           as Gen
import qualified Test.Falsify.Generator.Auxiliary as Gen
import qualified Test.Falsify.Predicate           as P
import qualified Test.Falsify.Range               as Range
import Data.Word

tests :: TestTree
tests = testGroup "TestSuite.Prop.Generator.Simple" [
      testGroup "Shrinking" [
          testProperty "prim" prop_prim
        , testGroup "signedWordN" [
              testProperty (show n) $ prop_signedWordN n
            | n <- [0 .. 9]
            ]
        , testGroup "signedFraction" [
              testProperty (show n) $ prop_signedFraction n
            | n <- [0 .. 9]
            ]
        , testGroup "integerFromFraction" [
              testProperty (show n) $ prop_integerFromFraction n
            | n <- [0 .. 9]
            ]
        , testProperty "integerWithPrecision" prop_integerWithPrecision
        , testGroup "integral" [
              testProperty "between_0_100" prop_between_0_100
            , testProperty "between_100_0" prop_between_100_0
            ]
        ]
    ]

-- Gen.prime is the only generator where we a /strict/ inequality
prop_prim :: Property ()
prop_prim =
    testShrinkingOfGen P.gt $
      Gen.prim

prop_signedWordN :: Word8 -> Property ()
prop_signedWordN n =
    testShrinkingOfGen (P.ge `P.on` (P.fn "forgetSign" Gen.forgetSign)) $
      Gen.signedWordN (Gen.Precision n)

prop_signedFraction :: Word8 -> Property ()
prop_signedFraction n =
    testShrinkingOfGen (P.ge `P.on` (P.fn "forgetSign" Gen.forgetSign)) $
      Gen.signedFraction (Gen.Precision n)

prop_integerFromFraction :: Word8 -> Property ()
prop_integerFromFraction n =
    testShrinkingOfProp P.ge $ do
      -- By having 'Gen.integerFromFraction' outside the call to 'gen', we get
      -- to see the value generated by 'Gen.signedFraction' in case of a
      -- counterexample.
      x <- Gen.integerFromFraction (Range.between (0, 100)) <$>
             gen (Gen.signedFraction $ Gen.Precision n)
      testFailed x

prop_integerWithPrecision :: Property ()
prop_integerWithPrecision =
    testShrinkingOfProp P.ge $ do
      -- It is important that we do not shrink the precision, because if we
      -- reinterpret the same value with less precision, then the result will
      -- not necessarily be smaller (this is basically the counterexample that
      -- is tested in the @mod@ tests in @Demo.TestShrinking).
      p <- gen $ Gen.withoutShrinking $
             Gen.Precision <$> Gen.integral (Range.between (0, 30))
      x <- gen $ Gen.integerWithPrecision p (Range.between (0, 100))
      testFailed x

prop_between_0_100 :: Property ()
prop_between_0_100 =
    testShrinkingOfGen P.ge $
      Gen.integral $ Range.between (0 :: Word, 100)

prop_between_100_0 :: Property ()
prop_between_100_0 =
    testShrinkingOfGen P.le $
      Gen.integral $ Range.between (100 :: Word, 0)

