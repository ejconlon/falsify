module TestSuite.Prop.Generator.Simple (tests) where

import Data.Default
import Data.Word
import Test.Tasty
import Test.Tasty.Falsify

import Test.Falsify.Predicate ((.$))

import qualified Test.Falsify.Generator           as Gen
import qualified Test.Falsify.Generator.Auxiliary as Gen
import qualified Test.Falsify.Predicate           as P
import qualified Test.Falsify.Range               as Range

tests :: TestTree
tests = testGroup "TestSuite.Prop.Generator.Simple" [
      testGroup "Shrinking" [
          testProperty "prim" prop_shrinking_prim
        , testGroup "signedWordN" [
              testProperty (show n) $ prop_shrinking_signedWordN n
            | n <- [0 .. 9]
            ]
        , testGroup "signedFraction" [
              testProperty (show n) $ prop_shrinking_signedFraction n
            | n <- [0 .. 9]
            ]
        , testGroup "integerFromFraction" [
              testProperty (show n) $ prop_shrinking_integerFromFraction n
            | n <- [0 .. 9]
            ]
        , testProperty "integerWithPrecision" prop_shrinking_integerWithPrecision
        , testGroup "integral" [
              testProperty "between_0_100" prop_shrinking_between_0_100
            , testProperty "between_100_0" prop_shrinking_between_100_0
            ]
        ]
    , testGroup "Minimum" [
          testProperty "prim" prop_minimum_prim
        ]
    , testPropertyWith (def { expectFailure = ExpectFailure })
        "prim_minimum_wrong" prop_minimum_prim_wrong
    ]

{-------------------------------------------------------------------------------
  Shrinking
-------------------------------------------------------------------------------}

-- Gen.prime is the only generator where we a /strict/ inequality
prop_shrinking_prim :: Property ()
prop_shrinking_prim =
    testShrinkingOfGen P.gt $
      Gen.prim

prop_shrinking_signedWordN :: Word8 -> Property ()
prop_shrinking_signedWordN n =
    testShrinkingOfGen (P.ge `P.on` (P.fn "forgetSign" Gen.forgetSign)) $
      Gen.signedWordN (Gen.Precision n)

prop_shrinking_signedFraction :: Word8 -> Property ()
prop_shrinking_signedFraction n =
    testShrinkingOfGen (P.ge `P.on` (P.fn "forgetSign" Gen.forgetSign)) $
      Gen.signedFraction (Gen.Precision n)

prop_shrinking_integerFromFraction :: Word8 -> Property ()
prop_shrinking_integerFromFraction n =
    testShrinkingOfProp P.ge $ do
      -- By having 'Gen.integerFromFraction' outside the call to 'gen', we get
      -- to see the value generated by 'Gen.signedFraction' in case of a
      -- counterexample.
      x <- Gen.integerFromFraction (Range.between (0, 100)) <$>
             gen (Gen.signedFraction $ Gen.Precision n)
      testFailed x

prop_shrinking_integerWithPrecision :: Property ()
prop_shrinking_integerWithPrecision =
    testShrinkingOfProp P.ge $ do
      -- It is important that we do not shrink the precision, because if we
      -- reinterpret the same value with less precision, then the result will
      -- not necessarily be smaller (this is basically the counterexample that
      -- is tested in the @mod@ tests in @Demo.TestShrinking).
      p <- gen $ Gen.withoutShrinking $
             Gen.Precision <$> Gen.integral (Range.between (0, 30))
      x <- gen $ Gen.integerWithPrecision p (Range.between (0, 100))
      testFailed x

prop_shrinking_between_0_100 :: Property ()
prop_shrinking_between_0_100 =
    testShrinkingOfGen P.ge $
      Gen.integral $ Range.between (0 :: Word, 100)

prop_shrinking_between_100_0 :: Property ()
prop_shrinking_between_100_0 =
    testShrinkingOfGen P.le $
      Gen.integral $ Range.between (100 :: Word, 0)

{-------------------------------------------------------------------------------
  Minimum values

  TODO: We should test these for the other generators too.
-------------------------------------------------------------------------------}

prop_minimum_prim :: Property ()
prop_minimum_prim =
    testMinimum (P.eq .$ ("expected", 0)) $ do
      x <- gen $ Gen.prim
      testFailed x

-- | Just to verify that we if we specify the /wrong/ minimum, we get a failure
prop_minimum_prim_wrong :: Property ()
prop_minimum_prim_wrong =
    testMinimum (P.eq .$ ("expected", 1)) $ do
      x <- gen $ Gen.prim
      testFailed x
